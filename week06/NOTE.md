## 有限状态机

- 每个状态都是一个机器
  - 每个机器可以计算、存储、输出
  - 所有机器接受的输入一致
  - 每个机器无状态
- 每个机器知道下一个状态
  - 每个机器有确定的下一个状态（Moore）
  - 每个机器根据输入决定下一个状态（Mealy）(常用)

```typescript
// 在一个字符串中找到字符"a"
function match(str: string) {
  let state = start;
  for (let c of str) {
    state = state(c);
  }
  return state === end;
}
// 找到字符a跳转到end状态、否则继续start
function start(c: string) {
  if (c === 'a') {
    return end;
  } else {
    return start;
  }
}
// 跳到end后就一直是end状态，不会变化（类似陷阱）
function end(c: string) {
  return end;
}
```

### 作业

[使用状态机完成“abababx”的处理](./match.js)

[使用状态机处理完全未知的pattern](./match-kmp.js)



## HTML解析

### 一、拆分文件

根据模块化思想，将parser单独作为一个模块，拆分到一个文件中，其接受HTML文本作为参数,返回一个DOM树。

### 二、创建状态机

[html最新标准中已经给出了所有的状态设计，本次挑选其中20个左右的状态实现一个基础版本。

### 三、解析标签

处理开始标签、结束标签和自封闭标签（忽略其它标签和容错情况）

### 四、创建元素

- 遇到开始标签创建token
- 创建attribute

### 五、处理属性

- 属性值有单引号、双引号、无引号三种写法
- 属性结束时、把属性加到token上

### 六、构建DOM树

- 使用栈结构构建DOM树
- 遇到开始标签入栈、遇到结束标签出栈
- 自闭和标签视为入栈后立即出栈
- 任何元素的父元素是当前栈顶

### 七、文本节点

- 与自闭和标签处理类似
- 多个文本节点需要合并



## CSS计算

### 一、收集css规则

- 在emit中遇到style结束标签把规则保存起来
- 使用CSS Parser来分析CSS规则

### 二、添加调用

- 创建一个元素后，立即计算CSS
- 分析一个元素时，所有的CSS应该已经收集完毕

### 三、获取父元素序列

- stack中保有当前元素的所有父元素
- 从内向外依次匹配

### 四、拆分选择器

- 从里向外排列
- 复杂选择器拆分成单个选择器，依次匹配

### 五、计算选择器与元素匹配

- 根据选择器的类型和元素属性，计算是否匹配

### 六、生成computed属性

- 匹配后，将选择器应用到元素上，形成computedStyle

### 七、确定规则覆盖关系

- 通过四元组来实现优先级



[作业](./parser.js)



